---
title: "DBS101_Unit5"
date: 22-04-2025  
categories: [DBS101, Unit5]  
tags: [DBS101, Normalization, BCNF, 3NF]  
---

# Unit 5: Database Normalization and Design Theory  

## My Initial Confusion üòÖ 

Before starting Unit 5, I knew databases could get messy-repeated data, weird update issues, and tables that just felt "off." I‚Äôd heard terms like "normalization" thrown around, but it sounded like math magic. My naive assumption? Normalization was just about splitting big tables into smaller ones.  

## What Unfolded in Unit 5 üß†  

### 1. **The "Why" Behind Normalization**  
I learned that normalization isn‚Äôt just organizational OCD - it solves real problems:  
- **Redundancy**: Storing the same data in multiple places wastes space and risks inconsistencies (e.g., a customer‚Äôs address appearing differently in two orders).  
- **Anomalies**:  
  - **Update Anomaly**: Fixing a professor‚Äôs office in 10 places because it‚Äôs duplicated.  
  - **Delete Anomaly**: Removing a student‚Äôs only enrollment accidentally deletes their entire record.  
  - **Insertion Anomaly**: Needing to fake a course enrollment just to add a new department.  

*Example from class*:  
The `in_dep(ID, name, salary, dept_name, building, budget)` table had *all* department details repeated for every instructor. Not efficient.

---

### 2. **Functional Dependencies (FDs): The Secret Sauce**  
FDs define how attributes relate:  
- `X ‚Üí Y` means "X determines Y" (e.g., `StudentID ‚Üí Name`).  
- **Closure (`F+`)**: All FDs logically implied by a set. Calculating it felt like detective work. 

*Lightbulb moment* üí°:  
Armstrong‚Äôs Axioms (Reflexivity, Augmentation, Transitivity) helped derive new FDs without brute force.  

---

### 3. **Normal Forms: A Tiered Approach**  
#### **1NF**: Atomic values only (no lists or nested attributes).  
- Fixed: Splitting `address` into `street`, `city`, `state`.  

#### **2NF**: No partial dependencies (non-prime attributes depend on *whole* candidate keys).  
- Example: In `Order(OrderID, ProductID, ProductName, Quantity)`, `ProductName` depended only on `ProductID` (not the full key). Solution? Split tables.  

#### **3NF**: No transitive dependencies (non-prime attributes depend *only* on candidate keys).  
- Fixed: Separating `Student(ID, Name, Dorm, DormFee)` into `Student(ID, Name, Dorm)` and `Dorm(Name, Fee)`.  

#### **BCNF**: Stricter than 3NF - every determinant must be a superkey.  
- Trade-off: BCNF eliminates redundancy but may sacrifice dependency preservation.  

*Class debate*: When to choose 3NF over BCNF? Answer: When preserving FDs matters more than perfect normalization.  

---

### 4. **Decomposition Algorithms**  
- **BCNF Algorithm**:  
  1. Find violating FD `X ‚Üí Y`.  
  2. Decompose into `(X ‚à™ Y)` and `(R - (Y - X))`.  
  3. Repeat until all relations satisfy BCNF.  
- **3NF Synthesis Algorithm**: Uses canonical cover to preserve dependencies.  

*Ah-ha moment* ü§Ø: Decomposition isn‚Äôt just splitting - it‚Äôs ensuring **lossless joins** (no fake tuples when recombining).  

---

### 5. **Beyond BCNF: 4NF & 5NF**  
- **4NF**: Tackles multivalued dependencies (e.g., an instructor with multiple departments *and* multiple addresses).  
- **5NF (PJNF)**: Handles join dependencies (rarely used in practice).  

*Reality check*: Higher normal forms are theoretically cool but often impractical.  

---

### 6. **Temporal Data Challenges**  
Adding time (e.g., `course_valid_from`, `course_valid_to`) complicates FDs:  
- `course_id ‚Üí title` only holds *at a point in time*.  
- Primary keys expand to include time periods (`(course_id, valid_period)`).  

---

## How My Perspective Shifted üîÑ  
I used to think normalization was about rigid rules. Now, I see it as a balancing act:  
- **Pros**: Cleaner data, fewer anomalies.  
- **Cons**: More tables, complex queries.  

*Key takeaway*: Sometimes, denormalizing (accepting redundancy) is okay for performance - but do it deliberately.  

---

## Homework Highlights ‚úçÔ∏è  

![Homework 1](/assets/unit5/hw1.jpg)

![Homework 1](/assets/unit5/hw1_1.jpg)

![Homework 2](/assets/unit5/hw2.jpg)

![Homework 2](/assets/unit5/hw2_1.jpg)

![Homework 2](/assets/unit5/hw2_2.jpg) 

---

**Final Thoughts**  
Unit 5 turned my vague "normalization = good" notion into a structured toolkit. I‚Äôm still nervous about designing a perfect schema, but now I have the tools to critique and improve.

***Thank you for reading - may your databases be anomaly-free! üéâ***  